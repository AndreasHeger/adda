####
####
##
## Project PythonTools
##
## Copyright (C) 2002 Andreas Heger All rights reserved
##
## Author: Andreas Heger <heger@ebi.ac.uk>
##
## $Id: Experiment.py,v 1.1 2002/11/18 13:00:34 heger Exp $
##
##
####
####

"""Module that contains some useful functions for
making experiments.
"""

import string,re,sys,time,inspect,getopt,os

global_starting_time = None
global_options = None
global_args    = None

def GetHeader():
    """return a header string with command line options and
    timestamp"""
    system, host, release, version, machine = os.uname()
    return "# output generated by %s\n# job started at %s on %s\n# pid: %i, system: %s %s %s %s" %\
           (string.join(sys.argv, " "),
            time.asctime(time.localtime(time.time())),
            host,
            os.getpid(),
            system, release, version, machine)

def GetParams( options = None):
    """return a string containing script parameters.
    Parameters are all variables that start with "param_".
    """
    result = []
    if options:
        members = options.__dict__
        for k, v in sorted(members.items()):
            result.append("# %-40s: %s" % (k, str(v).encode("string_escape")))
    else:
        vars = inspect.currentframe().f_back.f_locals
        for var in filter(lambda x: re.match("param_",x), vars.keys()):
            result.append("# %-40s: %s" % (var, str(vars[var]).encode("string_escape")))

    if result:
        return string.join(result, "\n")
    else:
        return "# no parameters."


def GetFooter():
    """return a header string with command line options and
    timestamp."""
    return "# job finished in %i seconds at %s -- %s" %\
           (time.time() - global_starting_time,
            time.asctime(time.localtime(time.time())),
            string.join( map( lambda x: "%5.2f" % x, os.times()[:4]), " "))

def Start( parser,
           quiet = False,
           add_csv_options = False,
           add_mysql_options = False,
           add_psql_options = False,
           add_pipe_options = True,
           add_cluster_options = False ):
    """set up an experiment."""
    
    global global_options, global_args, global_starting_time

    global_starting_time = time.time()

    parser.add_option("-v", "--verbose", dest="loglevel", type="int",
                      help="loglevel [%default]. The higher, the more output." )

    parser.add_option( "--timeit", dest='timeit_file', type="string",
                       help="store timeing information in file [%default]." )        
    parser.add_option( "--timeit-name", dest='timeit_name', type="string",
                       help="name in timing file for this class of jobs [%default]." )
                                     
    if quiet:
        parser.set_defaults( loglevel = 0 )
    else:
        parser.set_defaults( loglevel = 1 )

    parser.set_defaults(
        timeit_file = None,
        timeit_name = 'all',
        )

    if add_csv_options:
        parser.add_option("-I", "--dialect", dest="csv_dialect", type="string",
                          help="csv dialect to use [%default]." )

        parser.set_defaults(
            csv_dialect = "excel-tab",
            csv_lineterminator = "\n",
            )

    if add_psql_options:
        parser.add_option("-C", "--connection", dest="connection", type="string",
                          help="psql connection string [%default]."  )
        parser.add_option("-U", "--user", dest="user", type="string",
                          help="psql user name [%default]."  )
        
        parser.set_defaults( connection = "db:andreas" )
        parser.set_defaults( user = "" )
        
    if add_cluster_options:
        parser.add_option( "--use-cluster", dest="use_cluster", action = "store_true",
                          help="use cluster [%default]."  )
        parser.add_option( "--cluster-priority", dest="cluster_priority", type="int",
                          help="set job priority on cluster [%default]."  )
        parser.add_option( "--cluster-queue", dest="cluster_queue", type="string",
                          help="set cluster queue [%default]."  )
        parser.add_option( "--cluster-num-jobs", dest="cluster_num_jobs", type="int",
                          help="number of jobs to submit to the queue execute in parallel [%default]."  )
        
        parser.set_defaults( use_cluster = False,
                             cluster_queue = "medium_jobs.q",
                             cluster_priority = -10,
                             cluster_num_jobs = 100 )

    if add_pipe_options:
        parser.add_option("-L", "--log", dest="stdlog", type="string",
                          help="file with logging information [default = stdout].",
                          metavar = "FILE"  )
        parser.add_option("-E", "--error", dest="stderr", type="string",
                          help="file with error information [default = stderr].",
                          metavar = "FILE"  )
        parser.add_option("-S", "--stdout", dest="stdout", type="string",
                          help="file where output is to go [default = stdout].",
                          metavar = "FILE"  )
        
        parser.set_defaults( stderr = sys.stdout )
        parser.set_defaults( stdout = sys.stdout )
        parser.set_defaults( stdlog = sys.stdout )
        
    if add_mysql_options:
        parser.add_option("-H", "--host", dest="host", type="string",
                          help="mysql host [%default]."  )
        parser.add_option("-D", "--database", dest="database", type="string",
                          help="mysql database [%default]."  )
        parser.add_option("-U", "--user", dest="user", type="string",
                          help="mysql username [%default]."  )
        parser.add_option("-P", "--password", dest="password", type="string",
                          help="mysql password [%default]."  )
        parser.add_option("-O", "--port", dest="port", type="int",
                          help="mysql port [%default]."  )
        
        parser.set_defaults( host = "db",
                             port = 3306,
                             user = "",
                             password = "",
                             database = "" )

    (global_options, global_args) = parser.parse_args()

    if add_pipe_options:
        if global_options.stdout != sys.stdout: 
            global_options.stdout = open(global_options.stdout, "w")
        if global_options.stderr != sys.stdout:
            if global_options.stderr == "stderr":
                global_options.stderr = global_options.stderr
            else:
                global_options.stderr = open(global_options.stderr, "w")
        if global_options.stdlog != sys.stdout:
            global_options.stdlog = open(global_options.stdlog, "a")            
    else:
        global_options.stderr = sys.stderr
        global_options.stdout = sys.stdout
        global_options.stdlog = sys.stdout
    
    if global_options.loglevel >= 1:
        global_options.stdlog.write(GetHeader() + "\n" )
        global_options.stdlog.write(GetParams( global_options) + "\n")
        global_options.stdlog.flush()
        
    return global_options, global_args
    
def Stop():
    """stop the experiment."""

    if global_options.loglevel >= 1:
        global_options.stdlog.write(GetFooter() + "\n")

    if global_options.timeit_file:
        system, host, release, version, machine = map(str, os.uname())
        uusr, usys, c_usr, c_sys = map( lambda x: "%5.2f" % x, os.times()[:4])
        t_end = time.time()
        c_wall = "%5.2f" % (t_end - global_starting_time)

        cmd = global_args[0]
        if len(global_args) > 1:
            cmd += " '" + "' '".join(global_args[1:]) + "'" 

        result = "\t".join( (global_options.timeit_name,
                             c_wall, uusr, usys, c_usr, c_sys,
                             host, system, release, machine,
                             time.asctime(time.localtime( global_starting_time )),
                             time.asctime(time.localtime( t_end )),
                             os.path.abspath( os.getcwd() ),
                             cmd ) ) + "\n"

        outfile = open(global_options.timeit_file, "a")
        outfile.write( result )
        outfile.close()

class Experiment:

    mShortOptions = ""
    mLongOptions  = []

    mLogLevel = 0
    mTest = 0
    mDatabaseName = None

    mName = sys.argv[0]

    def __init__(self):

        # process command-line arguments
        (self.mOptlist, self.mArgs) = self.ParseCommandLine()

        # set options now
        self.ProcessOptions(self.mOptlist)

    def DumpParameters( self ):
        """dump parameters of this object. All parameters start with a lower-case m."""

        members = self.__dict__

	print "#--------------------------------------------------------------------------------------------"
        print "#" + string.join(sys.argv)
        print "# pid: %i, system:" % os.getpid(), string.join(os.uname(), ",") 
	print "#--------------------------------------------------------------------------------------------"
        print "# Parameters for instance of <" + self.mName + "> on " + time.asctime(time.localtime(time.time()))

        member_keys = list(members.keys())
        member_keys.sort()
        for member in member_keys:
            if member[0] == 'm':
                print "# %-40s:" % member, members[member]

	print "#--------------------------------------------------------------------------------------------"
        sys.stdout.flush()

    #-----------------------------> Control functions <--------------------------------

    ##------------------------------------------------------------------------------------
    def ProcessOptions( self, optlist ):
        """Sets options in this module. Please overload as necessary."""

        for o,a in optlist:
            if o in ( "-V", "--Verbose" ):
                self.mLogLevel = string.atoi(a)
            elif o in ( "-T", "--test") :
                self.mTest = 1

    ##------------------------------------------------------------------------------------        
    def ProcessArguments( self, args ):
        """Perform actions as given in command line arguments."""

        if self.mLogLevel >= 1:
            self.DumpParameters()
            
        for arg in args:
            if arg[-1] == ")":
                statement = "self.%s" % arg
            else:
                statement = "self.%s()" % arg
            exec statement

            if self.mLogLevel >= 1:
                print "--------------------------------------------------------------------------------------------"
                print statement + " finished at " + time.asctime(time.localtime(time.time()))
                print "--------------------------------------------------------------------------------------------"

    ##------------------------------------------------------------------------------------            
    def ParseCommandLine( self ):
        """Call subroutine with command line arguments."""

        self.mShortOptions = self.mShortOptions + "V:D:T"
        self.mLongOptions.append( "Verbose=" )
        self.mLongOptions.append( "Database=" )
        self.mLongOptions.append( "Test" )

        try:
            optlist, args = getopt.getopt(sys.argv[1:],
                                          self.mShortOptions,
                                          self.mLongOptions)
        except getopt.error, msg:
            self.PrintUsage()
            print msg
            sys.exit(2)

        return optlist, args

    #--------------------------------------------------------------------------------        
    def Process( self ):
        self.ProcessArguments(self.mArgs)

    #--------------------------------------------------------------------------------
    def PrintUsage( self ):
        """print usage information."""

        print "# valid short options are:", self.mShortOptions
        print "# valid long options are:", str(self.mLongOptions)

    
